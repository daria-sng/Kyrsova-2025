#include <stdio.h>    // Бібліотека стандартних функцій: ввід, вивід
#include <stdlib.h>   // Бібліотека стандартних функцій: функція exit(), системний виклик system()
#include <math.h>     // Бібліотека математичних функцій: функція pow()
#define N 3           // Директива #define для макропідстановки: N -> 3

struct parameters {   // Структура для параметрів: F, fi, S, p, v, Re, d, mu, v0, A, T, dt 
    double F, fi, S, p, v, Re, d, mu, v0, A, T, dt;    // Змінні типу double для збереження фізичних параметрів 
};

double counting_v(double v0, double A, double t, double T);  // Прототип функції: обчислення швидкості руху частинки - v
double counting_Re(double v, double d, double p, double mu); // Прототип функції: обчислення числа Рейнольдса - Re
double counting_fi(double Re);                               // Прототип функції: обчислення коефіцієнта спротиву - fi
double counting_S(double d);                                 // Прототип функції: обчислення площі проекції тіла - S
double counting_F(double fi, double S, double p, double v);  // Прототип функції: обчислення сили опору - F

void readout (struct parameters * array, int N1);            // Прототип функції: зчитування вхідних даних з окремого файла "Inputdata.txt" 
void results (struct parameters * array, int N1);            // Прототип функції: обчислення, виведення результатів у окремий файл "Results.txt" і на екран монітора

int main(){                     // Головна функція int main()
    system ("chcp 65001");       // Зміна кодування консолі: відображення кирилиці 
    struct parameters array[N]; // Масив з N структур типу parameters
    readout (array, N);         // Виклик функції: зчитування вхідних даних з окремого файла "Inputdata.txt" 
    results (array, N);         // Виклик функції: виведення результатів у окремий файл "Results.txt" і на екран монітора 
    return 0;                   // Повернення значення 0: успішне завершення програми 
}

double counting_v(double v0, double A, double t, double T){  // Функція обчислення швидкості руху частинки - v
    if(t>=0 && t<=T/4){                                      // Перевірка умови для першого випадку: від 0 (включно) до T/4 (включно)
        return v0 + (4*A/T)*t;                               // Одночасне обчислення даних за формулою: v0 + (4*A/T)*t і повернення результату у функцію results 
    }
    else if(t>=T/4 && t<=3*T/4){                             // Перевірка умови для другого випадку: від T/4 (включно) до 3*T/4 (включно)
        return v0 + A;                                       // Одночасне обчислення даних за формулою: v0 + A і повернення результату у функцію results 
    }
    else if(t>=3*T/4 && t<=T){                               // Перевірка умови для третього випадку: від 3*T/4 (включно) до T (включно) 
        return v0 + A - (t-3.0/4.0*T)*4*A/T;                 // Одночасне обчислення даних за формулою: v0 + A - (t-3.0/4.0*T)*4*A/T і повернення результату у функцію results 
    }
    else {                                                   // Умова, якщо час t виходить за межі всього інтервалу [0;T]
        printf("Увага! t > T\n");                            // Виведення тексту " Увага! t > T ": попередження про некоректне значення 
        return -1;                                           // Повернення значення -1: помилка 
    }
}

double counting_Re(double v, double d, double p, double mu){ // Функція обчислення значення числа Рейнольдса - Re
    return (v*d*p)/mu;                                       // Одночасне обчислення даних за формулою: (v*d*p)/mu і повернення результату у функцію results  
}

double counting_fi(double Re){                             // Функція обчислення коефіцієнту спротиву - fi 
    if(Re<=2){                                             // Перевірка умови для першого випадку: Re<=2
        return 24/Re;                                      // Одночасне обчислення даних за формулою: 24/Re і повернення результату у функцію results 
    }
    else if(Re>2 && Re<=500){                              // Перевірка умови для другого випадку: Re>2 і Re<=500
        return 18.5/pow(Re, 0.6);                          // Одночасне обчислення даних за формулою: 18.5/pow(Re, 0.6) і повернення результату у функцію results
    }
    else if(Re>500 && Re<=2e5){                            // Перевірка умови для третього випадку: Re>500 і Re<=2*10⁵
        return 0.44;                                       // Повернення значення 0,44 у функцію results
    }
    else {                                                 // Умова, якщо значення числа Рейнольдса > 2*10⁵ 
        printf("Значення числа Рейнольдса > 2*10⁵\n");     // Виведення тексту " Значення числа Рейнольдса > 2*10⁵ ": попередження про некоректне значення
        return -1;                                         // Повернення значення -1: помилка 
    }
}

double counting_S(double d){           // Функція обчислення площі проекції тіла - S
    const double Pi = 3.1415926535;    // Константна змінна типу double зі встановленим значенням: число π 
    return Pi*pow(d, 2)/4;             // Одночасне обчислення даних за формулою: Pi*pow(d, 2)/4 і повернення результату у функцію results
}

double counting_F(double fi, double S, double p, double v){    // Функція обчислення сили опору - F
    return fi*S*(p*pow(v,2)/2);                                // Одночасне обчислення даних за формулою: fi*S*(p*pow(v,2)/2) і повернення результату у функцію results
}

void readout (struct parameters * array, int N1){             // Функція зчитування вхідних даних з окремого файла "Inputdata.txt" і виведення вхідних даних на екран монітора 
    FILE *inputs = fopen("Inputdata.txt", "r");               // Відкриття файлу "Inputdata.txt" у режимі читання 
    if(inputs == NULL){                                       // Перевірка файла (Чи вдалося відкрити файл?)
        printf("Не відбулося відкривання файла Inputdata.txt, спробуйте ще раз!");   // Виведення тексту " Не відбулося відкривання файла Inputdata.txt, спробуйте ще раз! " у разі не успішного відкривання файлу 
        exit(1);                                              // Завершення програми з кодом помилки 1 
    }
    int i;                  // Змінна типу int 
    for(i=0; i<N1; i+=1){   // Цикл for для зчитування даних з файла "Inputdata.txt"
        fscanf(inputs, "T = %lf, dt = %lf, p = %lf, A = %lf, v0 = %lf, mu = %lf, d = %lf\n", &array[i].T, &array[i].dt, &array[i].p, &array[i].A, &array[i].v0, &array[i].mu, &array[i].d);          // Зчитування певних даних у відповідні комірки пам'яті 
        printf("Вхідні дані:\n%d. T = %lf, dt = %lf, p = %lf, A = %lf, v0 = %lf, mu = %lf, d = %lf\n", i+1, array[i].T, array[i].dt, array[i].p, array[i].A, array[i].v0, array[i].mu, array[i].d);  // Виведення вхідних даних на екран монітору з метою контролю програми
    }

    fclose(inputs);         // Закриття файлу "Inputdata.txt"
}

void results (struct parameters * array, int N1){     // Функція обчислення, виведення результатів у окремий файл "Results.txt" і на екран монітора
    FILE *outcome = fopen ("Results.txt", "w");       // Відкриття файлу "Results.txt" у режимі запису 
    if(outcome == NULL){                              // Перевірка файла (Чи вдалося відкрити файл?)
        printf("Не відбулося відкривання файла Results.txt, спробуйте ще раз!");    // Виведення тексту "Не відбулося відкривання файла Results.txt, спробуйте ще раз!" у разі не успішного відкривання файлу 
        exit(1);                                      // Завершення програми з кодом помилки 1 
    }
    int i;                    // Змінна типу int
    for (i=0; i<N1; i+=1){    // Цикл for для ітерації по кожному елементу масиву структур 
        fprintf(outcome, "Елемент %d у масиві структур\n", i+1);        // Запис інформації про поточний елемент у файл результатів
        printf("Елемент %d у масиві структур\n", i+1);                  // Виведення інформації про поточний елемент на екран монітора 
        for(double t=0; t<=array[i].T; t+=array[i].dt){                 // Цикл for для побудови графіка зміни сили опору на відрузку від 0 до T з кроком dt
            double v = counting_v(array[i].v0, array[i].A, t, array[i].T);     // Обчислення швидкості v
            double Re = counting_Re(v, array[i].d, array[i].p, array[i].mu);   // Обчислення числа Рейнольдса Re
            double fi = counting_fi(Re);                                       // Обчислення коефіцієнта спротиву fi
            double S = counting_S(array[i].d);                                 // Обчислення площі проекції тіла S
            double F = counting_F(fi, S, array[i].p, v);                       // Обчислення сили опору F 
            fprintf(outcome, "v = %lf, Re = %lf, fi = %lf, S = %e, F = %lf, t = %lf\n", v, Re, fi, S, F, t);   // Запис розрахованих параметрів у файл результатів
            printf("v = %lf, Re = %lf, fi = %lf, S = %e, F = %lf, t = %lf\n", v, Re, fi, S, F, t);             // Виведення результатів на екран монітора 
        }
    }
    fclose(outcome);        // Закриття файлу "Results.txt"
}